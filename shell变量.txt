-----------------------------------------------
read交互式赋值
read -p ：

-----------------------
条件测试语句
------------------------
1，test
2，[  ]
文件测试：
-d ：测试目录是否存在，或者 是否是目录
-e：测试文件或者目录是否存在（exist）
-f：测试文件是否存在或者是否是文件
-r：测试文件或者目录是否有读权限
-w：写
-x：执行


----------------------------------
多条件判断
逻辑测试：&& | ！

数字比较：
-gt ：大于
-lt：小于
-eq：等于
-ge：大于等于
-le：小于等于
-ne：不等于


字符串比较
= 相同
!= 不同
-z ：为空
----------------------------------
if 条件:
if [  ] then
	elif [  ] then
	fi 
fi

-------------------------------------------
监控http的允许状态

httpd :网站：
端口：80
服务名称：httpd

状态查询：service httpd status 
开始：service httpd start
停止:service httpd stop


#！/bin/bash
# this is http status scripts

service httpd status
if [ $? -eq 0] then 
 echo "http is run"
 	elif [ $? -ne 0]
	echo "http server running fail .Try to restart "  
	read -p "do restart httpd service (yes/no)" do 
		elif [ $do == yes]
			service httpd restart
			echo "httpd has restarted"
		else 
			exit
		fi
	fi
 
fi


---------------------------------------------------------------
系统维护的相关命令

ls命令  ls -l = ll
-l ：查看详细信息。
pwd
cd

date：显示和设置时间。
-s 设置时间。

psswd：修改密码。
su
clear
man

who：查看当前登录到系统的用户 
-a ：所有信息
-b：列出系统最近登录的时间
-l：显示所有终端的信息
-m：显示当前终端的信息
-r：显示系统的运行基本

w
-h:不显示输出信息的标题。
-l：用长格式输出，
-s：用短格式输出


uname:显示系统的相关信息
-m：显示cpu的位数
-r：显示内核版本
-a：全部
-n：显示主机名 =uname

uptime：输出系统任务队列信息。= w 

last
所有登录系统用户的相关信息
对于文件/var/log/wtmp
	-a:把从何处登录的主机和用户名显示在最后一行
	-R：不输出主机名和ip
	-x：显示系统开关机的信息
	-n：行数
	-d：将显示的ip转换为主机名称。


dmesg:显示系统信息
free:显示内存的信息
-b：以字节为单位显示
-m：以m
-g：以g

ps ：查看进程信息
-a：全部进程
-x：显示系统中的程序
-u：显示使用者的时间和名称
-f：显示详细的程序执行的名称

top：动态查看进程，实时监控。
-d ：指定屏幕刷新间隔
-i：不显示闲置或者僵尸进程
-c：显示进程的命令路径
-s：在安全模式下运行
-b：分屏显示输出
-n：输出信息的更新次数。


m：显示内存信息
i：隐藏闲置和僵尸进程
M：以内存大小排序
P：以cpu大小排序

------------------------------------
for循环

for 变量名 in 取值列表
do
	命令
done

变量可以为任何形式的值
取值列表为一个序列，先后顺序赋予变量。
-----------------------------------------------------------------
case语句：匹配一个值或者一个模式。匹配成果之后就执行匹配内容当中的命令。

case 变量 in
	mode1)
		command
		;;
	mode2)
		command
		;;
	*)
		command
		;;
esac
注意事项：
	取值后面必须是关键字in
	每一个模式后面必须是“”）”结束；
	取值可以为特定的值也可以是变量。
	esac关键字表示结尾
	双分号必须存在。	
case语句的执行流程。
	
路由器中的acl访问控制，类似于防火墙。

编写服务器启动脚本
	安装部署nginx服务器
	查看依赖包是不是存在
	rpm -q zlib-devel pcre-devel
	添加系统用户
	useradd -s /sbin/nolgin -M
	编译安装nginx，源码安装
	tar 
	configure
	make && make install
-------------------------------------------	
	编写服务器启动脚本
	/home/shell/nginx_up.sh
--------------------------------------
循环的控制符
	break：终止整个循环
	continue	：跳出当前的循环。
---------------------------------------
exit程序流程的控制
 exit status
	0:命令成功完成
	1：表示未知的错误
	2：勿用shell命令




--------------------------
shift 左移
shit 左移之后前一个执行的参数会作废，例如，当$1 执行完之后,$1作废，新进入的参数$2变为$1.
例如	
whie[ $# -ne 0 ] do
	echo "this is $1"
	shift
done

-------------------------------------
函数
function function_name (){
  command 	
}

function_name(){
 command
 return 
}


ecxit：命令退出整个脚本
break：中断函数的执行

return：返回函数执行之后的结果	

declare：（显示函数）
	-f：显示定义的函数清单
	-F：显示定义的函数名称

unset -f ：从shell内存当中删除函数。
export -f：将函数输出给shell


也可以在用户环境变量当中进行设置函数，.bashrc进行设置，当这个用户删除之后，其他的用户是不能使用它设置函数的额。

当其他的文件需要使用不在当前shell的函数的时候。
在当前脚本当中加入 source 函数所在的shell脚本 。将这个函数名称导入当前脚本当中，作为当前脚本的一个函数。关键字为source。

函数的参数的传递
	函数也可以通过位置变量传递参数
	函数名称 参数1 参数2 参数3
	function （）
	{
		echo“”$1“”
	}
	zhangshan
	lisi 

	函数的返回值
	return （0-256）之间的数，也可以通过$?进行返回。
	函数的加载
	其他的函数使用source
	函数的删除，unset -f 函数名称

----------------------
expect 无人交互功能
	expect有自己的语法格式和方式。
	作用：实现自动交互，无需人的干预
	使用expect之前需要先安装Tcl编辑工具
	
	
	工作原理：
		通过脚本实现自动的交互
			
		ssh远程自动登录
			#!/usr/bin/expect
			set timeout 30          ##设置程序超时的时间
			spawn ssh root@192.168.110.128 ##传递指令
			expect {
				“”yes/no“”{ send "yes\r";exp_continue} ## 判断是否有关键字yes/no 
返回发送字符串yes；则继续。
				"password:"{send "123456\r"}
				}
			interact

文件都是.exp的文件。
文件的执行都是expect 文件名。
---------------------------------------------------------------
正则表达式
-------------------------------------------------
数量限定字符：
？：紧跟在呀前面的单元匹配0次或者一次。
-：在括号[]使用，用于字符之间，表示字符的范围
^：在括号当中使用，表示取反。
{n，m}：紧跟在他前面的单元匹配n到m次，n表示最小值，{n，}表示最少匹配n次，{m，}，表示最多匹配m次。
[[:xxxxx:]]：grep 预定义的一些命名字符。



位置限定符

^ :匹配以什么开头的字符。^center 
$：匹配以什么结尾的的字符 center$
\<:以某个单词开头，单词一般以空格或者特殊字符做分割，连续的字符串被当做单词
\>:以某个单词结尾。
\d:匹配一个数字字符，相当于[0-9]
\D:匹配一个非数字字符。

------------------------------
cut 文件处理。
针对行进行分析，逐行的处理。
和sed的方式
cut 三个定位方式
	字节 -b
	字符 -c
	-d 指定分割符，默认为tab
	-f 显示指定字段的内容。
语法：
	cut -b 操作的范围 [file....................]
	cut -c 操作的范围 [file....................]
	cut -f 操作的范 围 [file....................]
	比如：who |cut -b 1-4
	获取用户名称。
	head -5 /etc/passwd |cut -d : -f 1
	
-----------------------------------------------------------
三剑客grep，sed，awk
-----------------------------------------------------------
sed 流编辑器
	优点：stream editor ：流编辑器的特点是不是直接处理文件，是将文本放入内存当中进行处理，处理完成之后进行显示或者修改文本。
	流程：
	1，把行读取到内存当中
	2，进行模式匹配
	3，使用sed命令编辑
	4，输出
sed的选项和语法：
	-n：不显示模式空间的内容，只显示符合条件的行
	-i：直接修改文件（小心使用）
	-e：多个操作同时进行。
address：地址范围
	lineNumber	指定特定的行
	Start，End 	起始行，结束行
	/^root/		正则表达式
	mode1,mode2	第一次被模式1匹配的行开始，到第一次被模式2匹配的行结束。
	startLine,+n  	从现在的行到往后的n行

command：
	d：删除
	p:输出
	c：取代 sed '7 c SELINUX=enfrocing'
	a \内容：在指定的行的后面在追加新的内容
	r \内容：在指定的行的前面追加新的内容
	r file：将指定的文件的内容添加到符合条件的行
	w file：将指定的文件的内容另存符合文件的行处 （即将显示内容追加到file当中）
	s/模式/字符/ :查找并替换。
s的修饰符：
	g；替换所有
	i：忽略大小写
例如：
	sed ‘1,2d’ a.txt	sed ‘3，$d’ a.txt     sed ‘1，+3d' a.txt
	删除1-2行		删除最后一行	删除1到4行
	sed -n '/^root/'p a.txt
	显示以root开头的行
	sed -n ‘/^root/’a \#there is a people a.xt
	显示的后面追加 there is .......................




--------------------------------------------
awk :文本处理
	按列对文件进行处理，
	awk是一种文本处理的编程语言
	处理流程：
		1，逐行读入文件
		2，对文件进行分片
		3，把每一片变成输出的对象。分为$1,$2...............................等
		4，输出

